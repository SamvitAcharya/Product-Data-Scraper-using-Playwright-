# -*- coding: utf-8 -*-
"""Iden_Challenge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SX6NKf4oeop5O4yC3Nchp1Wy61Uus-tq
"""

!pip install playwright asyncio
!playwright install
!apt-get install -y libnss3 libatk-bridge2.0-0 libxss1 libgtk-3-0 libasound2 libxcomposite1 libxrandr2 libxdamage1 libgbm1 libx11-xcb1 libxcb1

import asyncio
import json
import os
from pathlib import Path
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError
# Constants for Login
LOGIN_URL = "https://hiring.idenhq.com/"
EMAIL = "samvit.acharya05@gmail.com"
PASSWORD = "SrykKCe8"

# File to save session data
SESSION_FILE = "session.json"


# Step 1: Login and save session
async def login_and_save_session(page):
    print("[*] Logging in...")
    await page.goto(LOGIN_URL)
    await page.fill("input[type='Email']", EMAIL)
    await page.fill("input[type='Password']", PASSWORD)
    await page.click("button:has-text('Sign In')")
    await page.wait_for_load_state("networkidle")

    # Click "Launch Challenge" after login
    try:
        await page.wait_for_selector("button:has-text('Launch Challenge')", timeout=10000)
        await page.click("button:has-text('Launch Challenge')")
        await page.wait_for_load_state("networkidle")
        print("[+] Challenge launched.")
    except PlaywrightTimeoutError:
        print("[!] Launch Challenge button not found – continuing anyway.")

    print("[+] Logged in and session saved.")


# Step 2: Load existing session (if available)
async def load_storage(browser):
    context = await browser.new_context()
    try:
        with open(SESSION_FILE, "r") as file:
            session_data = json.load(file)
            await context.add_cookies(session_data['cookies'])
        print("[+] Session loaded from file.")
    except (FileNotFoundError, KeyError):
        print("[!] No session found. Proceeding with login.")
    return context


# Step 3: Save session after login
async def save_storage(context):
    cookies = await context.cookies()
    session_data = {"cookies": cookies}
    with open(SESSION_FILE, "w") as file:
        json.dump(session_data, file)
    print("[+] Session saved.")


async def navigate_to_product_table(page):
    print("[*] Navigating to product table...")

    # Step 1: Open Dashboard Menu
    await page.wait_for_selector("button:has-text('Open Dashboard Menu')")
    await page.click("button:has-text('Open Dashboard Menu')")
    print("[+] Open Dashboard Menu clicked.")

    # Step 2: Click Data Tools (twice)
    for i in range(2):
        await page.wait_for_selector("button:has-text('Data Tools')")
        await page.click("button:has-text('Data Tools')")
        print(f"[+] Data Tools clicked ({i+1}/2).")
        await page.wait_for_timeout(500)

    # Step 3: Click Inventory Options
    await page.wait_for_selector("button:has-text('Inventory Options')")
    await page.click("button:has-text('Inventory Options')")
    print("[+] Inventory Options clicked.")

    # Step 4: Click Open Products Drawer (First time)
    await page.wait_for_selector("button:has-text('Open Products Drawer')")
    await page.click("button:has-text('Open Products Drawer')")
    print("[+] Open Products Drawer clicked (first time).")
    await page.wait_for_timeout(1000)

    # Step 5: Click Open Products Drawer (Second time - precise selector)
    drawer_buttons = await page.locator("button:has-text('Open Products Drawer')").all()
    if len(drawer_buttons) >= 2:
        await drawer_buttons[1].click()
        print("[+] Open Products Drawer clicked (second time - specific button above View Summary).")
    else:
        print("[!] Second Open Products Drawer button not found.")

    # Step 6: Confirm product table is visible
    try:
        await page.wait_for_selector("table", timeout=15000)
        print("[+] Product dashboard is now visible.")
    except PlaywrightTimeoutError:
        print("[!] Product dashboard did not appear.")




# Step 5: Get table headers
async def get_headers(page):
    headers = []
    header_elements = await page.query_selector_all("table thead tr th")
    for header in header_elements:
        text = await header.inner_text()
        headers.append(text.strip())
    return headers


import re

async def extract_card_data(page):
    await page.wait_for_selector("div:has-text('ID:')", timeout=15000)
    product_cards = await page.locator("div:has-text('ID:')").all()
    product_list = []

    for card in product_cards:
        try:
            text = await card.inner_text()
            lines = text.strip().split('\n')

            # Extract using regex for reliability
            name = lines[0].strip()
            id_match = re.search(r"ID:\s*(\d+)", text)
            material_match = re.search(r"Material\s*(\w+)", text)
            stock_match = re.search(r"Stock\s*(\d+)", text)
            size_match = re.search(r"Size\s*([\d×\s]+cm)", text)

            product = {
                "Name": name,
                "ID": id_match.group(1) if id_match else None,
                "Material": material_match.group(1) if material_match else None,
                "Stock": int(stock_match.group(1)) if stock_match else None,
                "Size": size_match.group(1) if size_match else None
            }

            product_list.append(product)

        except Exception as e:
            print(f"[!] Error extracting a product card: {e}")

    print(f"[+] Extracted {len(product_list)} product cards.")
    return product_list




# Step 7: Export data to JSON file
def export_to_json(data, headers):
    output_data = []
    for row in data:
      row_dict = {key: row.get(key, "") for key in headers}
      output_data.append(row_dict)


    with open("product_data.json", "w") as file:
        json.dump(output_data, file, indent=4)
    print("[+] Data exported to 'product_data.json'.")


# Main function to handle all tasks
async def main():
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        context = await load_storage(browser)
        page = await context.new_page()

        try:
            # Try loading session if available
            await page.goto(LOGIN_URL)
            await page.wait_for_selector("text=Logout", timeout=5000)
            print("[+] Session reused")
        except PlaywrightTimeoutError:
            # If session is expired, log in again
            print("[*] Logging in again...")
            await login_and_save_session(page)
            await save_storage(context)

        # Navigate to product table
        await navigate_to_product_table(page)

        # Scrape headers and data
        headers = ["Name", "ID", "Material", "Stock", "Size"]
        data = await extract_card_data(page)

        # Debug: Check if headers and rows are extracted correctly
        print(f"[DEBUG] Headers: {headers}")
        print(f"[DEBUG] Total rows extracted: {len(data)}")

        # Export to JSON
        export_to_json(data, headers)

        # Close the browser
        await browser.close()


# Run the main function
await main()